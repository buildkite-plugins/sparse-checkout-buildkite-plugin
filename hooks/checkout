#!/bin/bash

set -euo pipefail

DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

# shellcheck source=lib/plugin.bash
. "$DIR/../lib/plugin.bash"

NO_CONE_OPTION="$(plugin_read_config NO_CONE "false")"
NO_CONE_PARAM=""
[[ $NO_CONE_OPTION = false ]] || NO_CONE_PARAM="--no-cone"

if plugin_read_list_into_result PATHS; then
    CHECKOUT_PATHS=("${result[@]}")
else
    echo "Missing 'paths' option in the plugin"
    exit 1
fi

SKIP_SSH_KEYSCAN_OPTION="$(plugin_read_config SKIP_SSH_KEYSCAN "false")"
CLEAN_CHECKOUT_OPTION="$(plugin_read_config CLEAN_CHECKOUT "false")"

if [[ "${CLEAN_CHECKOUT_OPTION}" = "true" ]]; then
    echo "⚠️  WARNING: clean_checkout is enabled - this will destroy any local changes and reset the repository state"
fi

if [[ -n "${BUILDKITE_REPO_SSH_HOST:-}" ]] && [[ "${SKIP_SSH_KEYSCAN_OPTION}" = "false" ]] ; then
    echo "Scanning SSH keys for remote git repository"
    [[ -d ~/.ssh ]] || mkdir -p ~/.ssh
    ssh-keyscan "${BUILDKITE_REPO_SSH_HOST}" >> ~/.ssh/known_hosts
else
    echo "Skipped SSH keyscan"
fi

echo "Creating sparse-checkout with paths: ${CHECKOUT_PATHS[*]}"

# clone the repo without checking out files if it does not exist already
if [[ ! -d .git ]]; then
    git clone \
        --depth 1 \
        --filter=blob:none \
        --no-checkout \
        ${BUILDKITE_REPO_MIRROR:+--reference "$BUILDKITE_REPO_MIRROR"} \
        -v \
        "${BUILDKITE_REPO}" .
fi

# Enable clean checkout option to deal with corrupted repository states
if [[ "${CLEAN_CHECKOUT_OPTION}" = "true" ]]; then
    echo "Clean checkout enabled - resetting repository state"
    # Remove index lock files
    find .git -name "*.lock" -delete 2>/dev/null || true
    # Reset index if corrupted
      if ! git status >/dev/null 2>&1; then
          rm -f .git/index 2>/dev/null || true
      fi
    # Disable sparse-checkout
      git sparse-checkout disable 2>/dev/null || true
    # Clean and reset
      git clean -ffxdq

      if git rev-parse --verify HEAD >/dev/null 2>&1; then
          git reset --hard HEAD
      fi
  else
      git clean -ffxdq
  fi

FETCH_FLAGS=()
if [[ -n "${BUILDKITE_GIT_FETCH_FLAGS:-}" ]]; then
    # Use read -a to split the flags safely and shellcheck-compliantly
    read -r -a FETCH_FLAGS <<< "${BUILDKITE_GIT_FETCH_FLAGS}"
fi

FETCH_FLAGS+=(--depth 1 origin)

if [[ ${BUILDKITE_COMMIT} = "HEAD" ]]; then
    FETCH_FLAGS+=( "${BUILDKITE_BRANCH}" )
else
    FETCH_FLAGS+=( "${BUILDKITE_COMMIT}" )
fi

git fetch "${FETCH_FLAGS[@]}"

git sparse-checkout set ${NO_CONE_PARAM:+--no-cone} "${CHECKOUT_PATHS[@]}"
if [[ ${BUILDKITE_COMMIT} = "HEAD" ]]; then
   git checkout FETCH_HEAD
else
   git checkout "${BUILDKITE_COMMIT}"
fi
